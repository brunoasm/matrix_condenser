
# This is the server logic for a Shiny web application.
# You can find out more about building applications with Shiny here:
#
# http://shiny.rstudio.com
#

library(shiny)
library(plyr)
options(shiny.maxRequestSize=1000*1024^2) 


# The following function parses a *.loci file generated by pyRAD
# It outputs a matrix of samples x loci, showing which loci where recovered for each sample
parseLociFile <- function(input_path){
  
  #first, get number of lines in file to report progress
  f <- file(input_path, open="rb")
  nlines <- 0L
  while (length(chunk <- readBin(f, "raw", 65536)) > 0) {
    nlines <- nlines + sum(chunk == as.raw(10L))
  }
  close(f)
  #now, read the file
  input_connection = file(input_path, "r")
  locus = 1
  loci = list()
  loci[[locus]] = logical()
  seqlines = character()
  n_lines_per_chunk = 1000000
  n_chuncks = ceiling(nlines/n_lines_per_chunk)
  withProgress(message = 'Reading *.loci file',
               value = 0,
               min = 0, 
               max = n_chuncks+1,
               expr = {
                 
                 while (TRUE){
                   incProgress(0.5)
                   lines = readLines(input_connection, n_lines_per_chunk)
                   if ( length(lines) == 0 ){break}
                   for (line in lines){
                     
                     if (!(grepl("//",line))){
                       #sample = strsplit(line,'\\s+')[[1]][1]
                       seqlines = c(seqlines,line)
                     } else {
                       samples = gsub('\\s.*$','',seqlines)
                       loci[[locus]] = rep(TRUE,length(samples))
                       names(loci[[locus]]) = samples
                       
                       locus = locus + 1
                       loci[[locus]] = logical()
                       seqlines = character()
                     }
                   }
                   incProgress(0.5)
                   
                 }
                 
                 close(input_connection)
                 
                 loci = loci[1:(length(loci)-1)]
                 
                 occmat = ldply(loci, function(x){t(data.frame(x))})
                 incProgress(0.5)
                 occmat[is.na(occmat)] = FALSE
                 occmat = t(occmat)
                 occmat = as.matrix(occmat)
                 colnames(occmat) = paste('locus',1:dim(occmat)[2],sep='_')
                 incProgress(0.5)
               })
  return(occmat)
}

parseOccMat <- function(input_path){
  occmat <- as.matrix(read.csv(file = input_path, header = T, row.names = 1, as.is = T))
  validate(
    need({dim(occmat)[2] > 0}, message = "Input not an occupancy matrix, check file type!")
  )
  samples = row.names(occmat)
  occmat = apply(occmat,2,as.logical)
  row.names(occmat) = samples
  return(occmat)
}

shinyServer(function(input, output) {
  #v will store values used accross reactive expressions, starting by plotting indicator
  v <- reactiveValues(doPlot = FALSE, reduced_matrix = matrix(NA,nrow = 1,ncol=1))
  
  # first, open and parse input file.
  # this is a reactive, so it will only be done once for each input file
  filetype <- reactive({
    switch(input$filetype,
           "Occupancy Matrix" = "occmatrix",
           "ipyrad *.loci" = "ipyrad_loci")
  })
  
  samples_vs_loci <- reactive({
    if (filetype() == "ipyrad_loci"){
      parseLociFile(input$locifile$datapath)
    } else if (filetype() == "occmatrix"){
      parseOccMat(input$locifile$datapath)
    }
  })
  
  #Offer option to download occupancy matrix
  output$downloadMatrix <- downloadHandler(
    filename = 'occupancy_matrix.csv',
    content = function(file){write.csv(samples_vs_loci(),file,row.names = T,col.names = T)}
  )
  
  
  #Then, generate output button and sliders for mincov and number of samples to remove
  output$downloadOutput <- renderUI({
    if (is.null(input$locifile)) return(NULL)
    if (filetype() == "occmatrix") return(NULL)
    downloadButton("downloadMatrix","Download occupancy matrix")
  })
  
  output$NremoveInput <- renderUI({
    if (is.null(input$locifile)) return(NULL)
    sliderInput("nremove", "Number of bad samples to remove:", 0, dim(samples_vs_loci())[1], 0, step = 1)
  })
  
  output$mincovInput <- renderUI({
    if (is.null(input$locifile)) return(NULL)
    if (length(v$last_value)){init = v$last_value} else {init = 0}
    sliderInput("mincov", "Minimum number of samples in a locus:", 0, dim(samples_vs_loci())[1]-input$nremove, min(init, dim(samples_vs_loci())[1]-input$nremove), step = 1)
  })
  
  output$graphExpansion <- renderUI({
    if (is.null(input$locifile)) return(NULL)
    sliderInput("graphExpansion", "Graph Expansion:", 5, 100, 80, step = 1, post = ' %', ticks = FALSE)
  })
  
  #create reactives to make action button work
  
  observeEvent(input$go, {
    v$doPlot <- input$go
  })
  
  observeEvent(input$nremove, {
    v$doPlot <- FALSE
  })
  
  observeEvent(input$mincov, {
    v$doPlot <- FALSE
    v$last_value <- input$mincov
  })
  
  observeEvent(input$graphExpansion, {
    v$doPlot <- FALSE
    v$graphExpansion <- input$graphExpansion
  })
  
  #Generate a reactive for reducing matrix
  reduce_matrix <- reactive({withProgress({
    #first, remove loci below mincov
    loci_to_keep <- apply(samples_vs_loci(), 2, sum) >= input$mincov
    reduced_matrix <- samples_vs_loci()[,loci_to_keep]
    
    #then check which samples have the least number of in loci in common
    samples_to_remove <- sort(rownames(reduced_matrix)[rank(apply(reduced_matrix, 1, sum),ties.method="max") <= input$nremove])
    samples_to_include <- sort(setdiff(rownames(reduced_matrix),samples_to_remove))
    
    #now, remove those samples from the full matrix and set mincov again
    reduced_matrix <-samples_vs_loci()[is.na(match(rownames(samples_vs_loci()), samples_to_remove)), ]
    loci_to_keep <- apply(reduced_matrix, 2, sum) >= input$mincov
    reduced_matrix <- reduced_matrix[,loci_to_keep]
    
    nloci = apply(reduced_matrix,1,sum)
    nsamples = apply(reduced_matrix,2,sum)
    
    reduced_matrix = reduced_matrix[order(nloci),order(nsamples,decreasing = T)]
    
    #now save variables to be used by other expressions
    v$samples_to_remove <- samples_to_remove
    v$samples_to_include <- samples_to_include
    v$reduced_matrix <- reduced_matrix
  },message = 'Rendering output')
  })
  
  #Plot graph when action button is pressed
  observe({
    if (v$doPlot == FALSE | is.null(input$locifile)){
      output$matrixOccupancy <- renderPlot({plot.new()})
    } else{
      output$matrixOccupancy <- renderPlot({
        isolate({
          reduce_matrix()
          #plot
          par('mar'= c(1,7.1,0,2.1))
          image(x = 1:dim(v$reduced_matrix)[2], y = 1:dim(v$reduced_matrix)[1], t(!v$reduced_matrix), col = c("black", "white"), yaxt='n', xaxt='n', xlab=NA, ylab=NA)
          axis(2,at = seq(1,dim(v$reduced_matrix)[1],1), rownames(v$reduced_matrix), tick = FALSE, las=1)
        })},
        height = v$graphExpansion/100*20*dim(v$reduced_matrix)[1])
      
    }
    
    
  })
  
  
  
  output$covHist <- renderPlot({
    if (v$doPlot == FALSE) return()
    isolate({
      reduce_matrix()
      #plot
      locus_counts <- apply(v$reduced_matrix, 1 ,sum)
      hist(locus_counts, xlab= "Number of loci in final dataset", main= "Number of loci per sample")
      axis(1,at = locus_counts,lwd = 0, lwd.ticks = 0.8, col.ticks = 'red', labels = FALSE, line = -.5)
    })})
  # And render texts and tables
  output$matOccText <- renderText({
    if (v$doPlot == FALSE) return()
    isolate({
      reduce_matrix()
      dims = dim(v$reduced_matrix)
      paste('Number of samples: ',dims[1],
            '\nNumber of loci: ',dims[2],
            '\nTotal missing data: ',sprintf('%2.2f',100*sum(!v$reduced_matrix)/(prod(dims))),'%', collapse = "")
    })
  })
  
  
  output$excludedSamples <- renderText({
    if (v$doPlot == FALSE) return()
    isolate({
      reduce_matrix()
      dims = dim(v$reduced_matrix)
      paste(v$samples_to_remove, collapse = " ")
    })
  })
  
  output$includedSamples <- renderText({
    if (v$doPlot == FALSE) return()
    isolate({
      reduce_matrix()
      paste(v$samples_to_include, collapse = " ")
    })
  })
  
  output$missingTable <- renderDataTable({
    if (v$doPlot == FALSE) return()
    isolate({
      reduce_matrix()
      missing_table <- data.frame(samples= rownames(v$reduced_matrix),
                                  pmissing= 100-apply(v$reduced_matrix,1,function(x){mean(x)*100}))
      names(missing_table) <- c("Sample IDs", "Loci missing (%)")
      return(missing_table)
    })
  })
  
  
})
